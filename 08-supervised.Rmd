# Supervised {#supervised}

Machine learning is very similar to statistics, but it is certainly not the same.
As the name suggests, in machine learning we want machines to learn.
This means that we want to replace hard-coded expert algorithm, with data-driven self-learned algorithm.

There are many learning setups, that depend on what is available to the machine. 
The most common setup, discussed in this chapter, is _supervised learning_.
The name takes from the fact that by giving the machine data samples with known inputs (a.k.a. features) and desired outputs (a.k.a. labels), the human is effectively supervising the learning. 
If we think of the inputs as predictors, and outcomes as predicted, it is no wonder that supervised learning is very similar to statistical prediction.
When asked "are these the same?" I like to give the example of internet fraud.
If you take a sample of fraud "attacks", a statistical formulation of the problem is highly unlikely. 
This is because fraud events are not randomly drawn from some distribution, but rather, arrive from an adversary learning the defenses and adapting to it. 
This instance of supervised learning belongs in game theory, more than it does in statistics. 

Other types of machine learning problems include: 

- __Unsupervised learning__: See Chapter \@ref(unsupervised).
- __Semi supervised learning__: Where only part of the samples are labeled. A.k.a. _co-training_, _learning from labeled and unlabeled data_, _transductive learning_. 
- __Active learning__: Where the machine is allowed to query the user for labels. Very similar to _adaptive design of experiments_. 
- __Reinforcement learning__:  Similar to active learning, in that the machine may query for labels. Different from active learning, in that the machine does not receive labels, but _rewards_. 
- __Learning on a budget__: A version of active learning where querying for labels induces variable costs.
- __Structure learning__: The learning of the dependence structure between variables. 
- __Learning to learn__: Deals with the carriage of "experience" from one learning problem to another. A.k.a. _cummulative learning_ and _meta learning_.
- __Manifold learning__: An instance of unsupervised learning, where the goal is to reduce the dimension of the data by embedding it into a lower dimensional manifold. A.k.a. _support estimation_.





## Problem setup

We now present the _empirical risk minimization_ to supervised learning. 

```{remark}
We do not discuss purely algorithmic approaches such as K-nearest neighbour and _kernel smoothing_ due to space constraints. 
For a broader review of supervised learning, see the Bibliographic Notes section.
```


Given $n$ samples with inputs $x$ from some space $\mathcal{X}$ and desired outcome, $y$, from some space $\mathcal{Y}$.
Samples, $(x,y)$ have some distribution we denote $P$.
We want to learn a function that maps inputs to outputs. 
This function is called a _hypothesis_, or _predictor_, or _classifier_ denoted $f$, that belongs to a hypothesis class $\mathcal{F}$ such that $f:\mathcal{X} \to \mathcal{Y}$.
We also choose some other function that fines us for erroneous prediction.
This function is called the _loss_, and we denote it by $l:\mathcal{Y}\times \mathcal{Y} \to \mathbb{R}^+$.

```{remark}
The _hypothesis_ in machine learning is only vaguely related the _hypothesis_ in statistical testing, which is quite confusing.
```

```{remark}
The _hypothesis_ in machine learning is not a bona-fide _statistical model_ since we don't assume it is the data generating process, but rather some function which we choose for its good predictive performance. 
```


The fundamental task in supervised (statistical) learning is to recover a hypothesis that minimizes the average loss in the sample, and not in the population.
This is know as the _risk minimization problem_.
\begin{align}
  f^* := argmin_f \{ E_P[l(f(x),y)] \}
  (\#eq:risk)  
\end{align}

To make things more explicit, $f$ may be a linear function, and $l$ a squared error loss, in which case problem \@ref(eq:risk) collapses to 
\begin{align}
  f^* := argmin_\beta \{ E_P[(x'\beta-y)^2] \}
\end{align}

Another fundamental problem is that we do not know the distribution of all possible inputs and outputs, $P$.
We typically only have a sample of $(x_i,y_i), i=1,\dots,n$.
We thus state the _empirical_ counterpart of \@ref(eq:risk), which consists of minimizing the average loss.
This is known as the _empirical risk miminization_ problem (ERM).
\begin{align}
  \hat f := argmin_f \{ \sum_i l(f(x_i),y_i) \}
  (\#eq:erm)  
\end{align}

Making things more explicit again by using a linear hypothesis with squared loss, we see that the empirical risk minimization problem collapses to an ordinary least-squares problem:
\begin{align}
  \hat f := argmin_\beta \{ \sum_i (x_\beta-y_i)^2 \}
\end{align}

When data is samples are independent, then maximum likelihood estimation is also an instance of ERM, when using the (negative) log likelihood as the loss function.

If we don't assume any structure on the hypothesis, $f$, then $\hat f$ from \@ref(eq:erm) will interpolate the data, and will be a very bad predictor. 
We say, it will _overfit_ the observed data, and will have bad performance on new data.

We have several means avoid overfitting:

1. Restrict the hypothesis class $\mathcal{F}$ (such as linear functions).
1. Penalize for the complexity of $f$. The penalty denoted by $\Vert f \Vert$.
1. Unbiased risk estimation, where we deal with the overfitted optimism of the empirical risk by debiasing it.

### Common Hypothesis Classes
Some common hypothesis classes, $\mathcal{F}$, with restricted complexity, are:

1. __Linear hypotheses__: such as linear models, GLMs, and (linear) support vector machines (SVM).
1. __Neural networks__: a.k.a. _feed-forward_ neural nets, _artificial_ neural nets, and the celebrated class of _deep_ neural nets.
1. __Reproducing Kernel Hilbert Space__: a.k.a. RKHS, is a subset of "the space of all functions^[It is even a subset of the Hilbert space, itself a subset of the space of all functions.]" that is both large enough to capture very complicated relations, but small enough so that it is less prone to overfitting, and also surprisingly simple to compute with. 
1. __Tree__: a.k.a. _decision rules_, is a class of hypotheses which can be stated as "if-then" rules. 
1. __Ensembles__: a "meta" hypothesis class, which consists of taking multiple hypotheses, possibly from different classes, and combining them. 


### Common Complexity Penalties
The most common complexity penalty applied to classes that have a finite dimensional parametric representation, such as a the linear class parametrized via its coefficients $\beta$.
In such classes we may penalize for the norm of the parameters.
Common penalties include:

1. __Ridge penalty__: penalizing the $l_2$ norm of the parameter. I.e. $\Vert f \Vert=\Vert \beta \Vert_2^2=\sum_j \beta_j^2$. 
1. __Lasso penalty__: penalizing the $l_1$ norm of the parameter. I.e., $\Vert f \Vert=\Vert \beta \Vert_1=\sum_j |\beta_j|$
1. __Elastic net__: a combination of the lasso and ridge penalty. I.e. ,$\Vert f \Vert= \alpha \Vert \beta \Vert_2^2 + (a-\alpha) \Vert \beta \Vert_1$.

If the hypothesis class $\mathcal{F}$ does not admit a finite dimensional parametric representation, we may penalize it with some functional norm such as $\Vert f \Vert_2^2=\int f(t)^2 dt$. 


### Unbiased Risk Estimation
The fundamental problem of overfitting, is that the empirical risk, \@ref(eq:erm), is downward biased to the true risk \@ref(eq:risk), a.k.a. _generalization error_, and _test error_.
Why is that? 
Think of estimating a population's  mean with the sample minimum. 
It can be done, but the minimum has to be debiased for it to estimate the population mean.
Debiasing methods broadly fall under purely algorithmic _resampling_ based approaches, and theory driven debiasing corrections. 
These corrections feel like the penalties above, but we state them here because unlike the ridge, and lasso, they are designed for a different purpose.

1. __Train,Validate,Test__: The simplest form of validation is to split the data. 
A _train_ set to train a set of hypotheses. 
A _validation_ set to compute the out-of-sample expected loss, and pick the best performing hypothesis. 
A _test_ sample to compute the out-of-sample performance of the selected hypothesis.
This is a very simple approach, but it is very "data inefficient", thus motivating the next method.
1. __V-fold cross validation__: 
By far the most popular performance assessment algorithm, in _V-fold CV_ we "fold" the data into $V$ non-overlapping sets. 
For each of the $V$ sets, we fit a hypothesis to the non-selected fold, and assess the expected loss on the selected loss. 
We then aggregate results over the $V$ folds, typically by averaging. 
1. __AIC__:
Akaike's information criterion (AIC) is a theory driven correction of the empirical risk, so that it is unbiased to the true risk.
It is appropriate when using the likelihood loss. 
1. __Cp__: 
Mallow's Cp is an instance of AIC for likelihood loss under normal noise.

Other theory driven unbiased risk estimators include the _Bayesian Information Criterion_ (BIC, aka SBC, aka SBIC), the _Minimum Description Length_ (MDL), _Vapnicâ€™s Structural Risk Minimization_ (SRM), the _Deviance Information Criterion_ (DIC), and the _Hannan-Quinn Information Criterion_ (HQC).

Other resampling based unbiased risk estimators include resampling __without replacement__ algorithms like _delete-d cross validation_ with its many variations, and __resampling with replacement__, like the _bootstrap_, with its many variations.



### Collecting the Pieces

Collecting ideas from the above sections, a typical supervised learning pipeline will include: choosing the hypothesis class, choosing the penalty function, choosing the assessment algorithm. 

Examples of such combos include:

1. Linear regression, no penalty, train-validate test.
1. Linear regression, no penalty, AIC.
1. Linear regression, $l_2$ penalty, V-fold CV. This combo is typically known as _ridge regression_.
1. Linear regression, $l_1$ penalty, V-fold CV. This combo is typically known as _lasso regression_.
1. Linear regression, $l_1$ and $l_2$ penalty, V-fold CV. This combo is typically known as _elastic net regression_.
1. Logistic regression, $l_2$ penalty, V-fold CV.
1. SVM classification, $l_2$ penalty, V-fold CV.
1. Deep network, no penalty, V-fold CV.




## Supervised Learning in R
At this point, we have a rich enough language to do supervised learning with R.

In these examples, I will use two data sets from the __ElemStatLearn__ package: 
`spam` for categorical predictions (spam mail or not spam?), and `prostate` for continuous predictions (size of cancerous tumor).
In `spam` we will try to decide if a mail is spam or not. 
In `prostate` we will try to predict the size of a cancerous tumor.
You can now call `?prostate` and `?spam` to learn more about these data sets.

Some pre-processing. The package __dplyr__ will be explained in the Hadley-verse Chapter \@ref(hadley).
```{r}
library(ElemStatLearn) # for data
data("prostate")
data("spam")

library(magrittr) # for piping
library(dplyr) # for handeling data frames

# Preparing prostate data
prostate.train <- prostate %>% # make train sample
  filter(train) %>% 
  select(-train) 
prostate.test <- prostate %>% # make test sample
  filter(!train) %>% 
  select(-train)
y.train <- prostate.train$lcavol
X.train <- prostate.train %>% select(-lcavol) %>% as.matrix
y.test <- prostate.test$lcavol 
X.test <- prostate.test %>% select(-lcavol) %>% as.matrix


# Preparing spam data:
n <- nrow(spam)

train.prop <- 0.66
train.ind <- c(TRUE,FALSE) %>%  
  sample(size = n, prob = c(train.prop,1-train.prop), replace=TRUE)
spam.train <- spam[train.ind,]
spam.test <- spam[!train.ind,]

y.train.spam <- spam.train$spam
X.train.spam <- spam.train %>% select(-spam) %>% as.matrix
y.test.spam <- spam.test$spam
X.test.spam <- spam.test %>% select(-spam) %>% as.matrix

spam.dummy <- spam %>% mutate(spam=as.numeric(spam=='spam'))
spam.train.dummy <- spam.dummy[train.ind,]
spam.test.dummy <- spam.dummy[!train.ind,]
```



We also load some utility packages and functions that we will require down the road. 
```{r}
l2 <- function(x) x^2 %>% sum %>% sqrt 
l1 <- function(x) abs(x) %>% sum  
MSE <- function(x) x^2 %>% mean 
missclassification <- function(tab) sum(tab[c(2,3)])/sum(tab)
```


Starting with OLS regression, and a train-test data approach. 
Notice the better in-sample MSE than the out-of-sample. 
That is overfitting in action.
```{r OLS Regression}
ols.1 <- lm(lcavol~. ,data = prostate.train)
MSE( predict(ols.1)- prostate.train$lcavol) # Train error:
MSE( predict(ols.1, newdata = prostate.test)- prostate.test$lcavol)# Test error:
```

Now using v-fold:
```{r }
folds <- 10
fold.assignment <- sample(1:5, nrow(prostate), replace = TRUE)
errors <- NULL

for (k in 1:folds){
  prostate.cross.train <- prostate[fold.assignment!=k,]
  prostate.cross.test <-  prostate[fold.assignment==k,] 
  .ols <- lm(lcavol~. ,data = prostate.cross.train)
  .predictions <- predict(.ols, newdata=prostate.cross.test)
  .errors <-  .predictions - prostate.cross.test$lcavol
  errors <- c(errors, .errors)
}

# Cross validated prediction error:
MSE(errors)
```

Let's try all possible models, and choose the best performer with respect to the Cp criterion.
We see that the best performer has 3 predictors. 
```{r, cache=TRUE}
library(leaps)
regfit.full <- prostate.train %>% 
  regsubsets(lcavol~.,data = ., method = 'exhaustive') # best subset selection
plot(regfit.full, scale = "Cp")
```


Instead of the Cp criterion, we now compute the train and test errors for all the possible predictors^[Example taken from https://lagunita.stanford.edu/c4x/HumanitiesScience/StatLearning/asset/ch6.html].

```{r, results='hold'}
model.n <- regfit.full %>% summary %>% length
X.train.named <- prostate.train %>% model.matrix(lcavol ~ ., data = .)  
X.test.named <- prostate.test %>% model.matrix(lcavol ~ ., data = .)  

val.errors <- rep(NA, model.n)
train.errors <- rep(NA, model.n)
for (i in 1:model.n) {
    coefi <- coef(regfit.full, id = i)
    
    pred <-  X.train.named[, names(coefi)] %*% coefi
    train.errors[i] <- MSE(y.train - pred)

    pred <-  X.test.named[, names(coefi)] %*% coefi
    val.errors[i] <- MSE(y.test - pred)
}
plot(train.errors, ylab = "MSE", pch = 19, type = "black")
points(val.errors, pch = 19, type = "b", col="blue")
legend("topright", 
       legend = c("Training", "Validation"), 
       col = c("black", "blue"), 
       pch = 19)
```



Checking all possible models is computatinally very hard.
_Forward selection_ is a greedy approach that adds one variable at a time, using the AIC criterion. If AIC falls, the variable is added. 

```{r, cache=TRUE}
# Forward search:
ols.0 <- lm(lcavol~1 ,data = prostate.train)
model.scope <- list(upper=ols.1, lower=ols.0)
step(ols.0, scope=model.scope, direction='forward', trace = TRUE)
```


We now learn a linear predictor on the `spam` data using, with least squares loss, and train-test validation. 
```{r}
# train the predictor
ols.2 <- lm(spam~., data = spam.train.dummy) 

# make in-sample predictions
.predictions.train <- predict(ols.2) > 0.5 
# inspect the confusion matrix
(confusion.train <- table(prediction=.predictions.train, truth=spam.train.dummy$spam)) 
# compute the train (in sample) misclassification
missclassification(confusion.train) 

# make out-of-sample prediction
.predictions.test <- predict(ols.2, newdata = spam.test.dummy) > 0.5 
# inspect the confusion matrix
(confusion.test <- table(prediction=.predictions.test, truth=spam.test.dummy$spam))
# compute the train (in sample) misclassification
missclassification(confusion.test)
```





## Bibliographic Notes
The ultimate reference on (statistical) machine learning is @friedman2001elements.
For a softer introduction, see @james2013introduction.
A statistician will also like @ripley2007pattern.
For an R oriented view see @lantz2013machine.
For a very algorithmic view, see the seminal @leskovec2014mining or @conway2012machine.
For a much more theoretical reference, see @mohri2012foundations, @vapnik2013nature, @shalev2014understanding.
Terminology taken from @sammut2011encyclopedia.
For a review of resampling based unbiased risk estimation (i.e. cross validation) see the exceptional review of @arlot2010survey.


# Parallel Computing {#parallel}

You would think that because you have an expensive multicore computer your computations will speed up. 
Well, no.
At least not if you don't make sure they do.
By default, no matter how many cores you have, the operating system will allocate each R session to a single core. 

For starters, we need to distinguish between two types of parallelism:

1. __Explicit parallelism__: where the user handles the parallelisation. 
1. __Implicit parallelism__: where the compiler handles the nonparallel.

Clearly, implicit parallelism is more desirable, but the state of mathematical computing is such that no sufficiently general implicit parallelism framework exists. 
The [R Consortium](https://www.r-consortium.org/projects/awarded-projects) is currently financing a major project for a A "Unified Framework For Distributed Computing in R" so we can expect things to change soon. 
In the meanwhile, most of the parallel implementations are explicit. 



## Explicit Parallelism

R provides many frameworks for explicit parallelism.
Because the parallelism is initiated by the user, we first need to decide __when to parallelize?__
As a rule of thumb, you want to parallelise when you encounter a CPU bottleneck, and not a memory bottlenck.
Memory bottlenecks are released with Sparsity (Chapter \@ref(sparse)), or efficient representation (Chapter \@ref(memory)).

Several ways to diagnose your bottlenck include:

- Keep your Windows Task Manager, or Linux `top` open, and look for the CPU load. 
- The computation takes a long time, and when you stop it pressign ESC, R is immediatly responsive (if it is not immediatly responsive, you have a memory bottlenck).
- Profile your code. See Hadley's [guide](http://adv-r.had.co.nz/Profiling.html).

For reasons detailed in @kane2013scalable, we will present the __foreach__ parallelisation package [@foreach]. 
It will allow us to: 

1. Decouple between our parallel algorithm and the parallelisation mechanism: we write parallelisable code once, and can then switch the underlying parallesation mechanism. 

1. Combine with the `big.matrix` object from Chapter \@ref(memory) for _shared memory parallisation_: all the machines may see the same data, so that we don't need to export objects from machine to machine. 


What do we mean by "switch the underlying parallesation mechanism"? 
It means there are several packages that will handle communication between machines. 
Some are very general and will work on any cluster that does not even need to be on the same machine. 
Some are more specific and will work only on a single multicore machine (not a cluster) with a particular operating system.
These mechanisms include __multicore__, __snow__, __parallel__, and __Rmpi__.
The compatibility between these mechanisms and __foreach__ is provided by another set of packages:
__doMC__ , __doMPI__, __doRedis__, __doParallel__, and __doSNOW__.


```{remark}
I personally prefer the __multicore__ mechanism, with the __doMC__ adapter for __foreach__.
I will not use this combo, however, because __multicore__ will not work on Windows machines.
I will thus use the more general __snow__ and __doParallel__ combo. 
If you do happen to run on Linux, or Unix, you will want to replace all __doParallel__ functionality with __doMC__.
```


Let's start with a simple example

```{r}

```







## Implicit Parallelism







## Bibliographic Notes
For a brief and excellent explanation on parallel computing in R see @schmidberger2009state.
For a full review see @chapple2016mastering.
For an up-to-date list of packages supporting parallel programming see the High Performance Computing [R task view](https://cran.r-project.org/web/views/HighPerformanceComputing.html).

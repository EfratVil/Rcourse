# Supervised {#supervised}

Machine learning is very similar to statistics, but it is certainly not the same.
As the name suggests, in machine learning we want machines to learn.
This means that we want to replace hard-coded expert algorithm, with data-driven self-learned algorithm.

There are many learning setups, that depend on what is available to the machine. 
The most common setup, discussed in this chapter, is _supervised learning_.
The name takes from the fact that by giving the machine data samples with known inputs (a.k.a. features) and desired outputs (a.k.a. labels), the human is effectively supervising the learning. 
If we think of the inputs as predictors, and outcomes as predicted, it is no wonder that supervised learning is very similar to statistical prediction.
When asked "are these the same?" I like to give the example of internet fraud.
If you take a sample of fraud "attacks", a statistical formulation of the problem is highly unlikely. 
This is because fraud events are not randomly drawn from some distribution, but rather, arrive from an adversary learning the defenses and adapting to it. 
This instance of supervised learning belongs in game theory, more than it does in statistics. 

Other types of machine learning problems include:

- __Unsupervised learning__: See Chapter \@ref(unsupervised)
- __Semi supervised learning__: Where only part of the samples are labeled.  
- __Active learning__: Where the machine is allowed to query the user for labels. 
- __Reinforcement learning__:  
- __Structure learning__: 
- __Structural learning__: 
- __Transductive learning__:
- __Developpmental learning__:
- __Learning to learn__:
- __Manifold learning__: An instance of unsupervised learning, where the goal is to reduce the dimension of the data by embedding it into a lower dimensional manifold. A.k.a. _support estimation_.
- __Metric learning__:
- __Learning on a budget__:




## Problem setup

Given $n$ samples with inputs $x$ from some space $\mathcal{X}$ and desired outcome, $y$, from some space $\mathcal{Y}$.
Samples, $(x,y)$ have some distribution we denote $P$.
We want to learn a function that maps inputs to outputs. 
This function is called a _hypothesis_, and we denote it with $f$ that belongs to a hypothesis class $\mathcal{F}$ such that $f:\mathcal{X} \to \mathcal{Y}$.
We also choose some other function that fines us for erroneous prediction.
This function is called the _loss_, and we denote it by $l:\mathcal{Y}\times \mathcal{Y} \to \mathcal{R}^+$.

```{remark}
The _hypothesis_ in machine learning is only vaguely related the hypothese in statistical testing, which is quite confusing.
```

```{remark}
The _hypothesis_ in machine learning is not a bona-fide statistical model in that we don't assume it is the data generating process, but rather some function which we choose for its good predictive performance. 
```


The fundamental task in supervised (statistical) learning is to recover a hypothesis that minimizes the average loss. 
This is know as the _risk minimization problem_.
\begin{align}
  f^* := argmin_f \{ E_P[l(f(x),y)] \}
  (\#eq:risk)  
\end{align}

To make things more explicit, $f$ may be a linear function, and $l$ a squared error loss, in which case problem \@ref(eq:risk) collapses to 
\begin{align}
  f^* := argmin_\beta \{ E_P[(x'\beta-y)^2] \}
\end{align}

Another fundamental problem is that we do not know the distribution of all possible inputs and outputs, $P$.
We typically only have a sample of $(x_i,y_i), i=1,\dots,n$.
We thus state the _empirical_ counterpart of \@ref(eq:risk), which consists of minimizing the average loss.
This is known as the _empirical risk miminization_ problem.
\begin{align}
  \hat f := argmin_f \{ \sum_i l(f(x_i),y_i) \}
  (\#eq:erm)  
\end{align}

Making things more explicit again by using a linear hypothesis with squared loss, we see that the empirical risk minimization problem collapses to an ordinary least squares problem:
\begin{align}
  \hat f := argmin_\beta \{ \sum_i (x_\beta-y_i)^2 \}
\end{align}

If we don't assume any structure on the hypothesis, $f$, then $\hat f$ from \@ref(erm) will interpolate the data, and will be a very bad predictor. 
We say, it will _overfit_ the observed data, and will have bad performance on new data.

We have several means avoid overfitting:

1. Restrict the hypothesis class $\mathcal{F}$ (such as linear functions).
1. Penalize for the complexity of $f$.
1. Assess the loss on an independent sample. 

### Commoon Hypothesis Classes


### Common Complexity Penalties


## Supervised Learning in R


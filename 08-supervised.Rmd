# Supervised {#supervised}

Machine learning is very similar to statistics, but it is certainly not the same.
As the name suggests, in machine learning we want machines to learn.
This means that we want to replace hard-coded expert algorithm, with data-driven self-learned algorithm.

There are many learning setups, that depend on what is available to the machine. 
The most common setup, discussed in this chapter, is _supervised learning_.
The name takes from the fact that by giving the machine data samples with known inputs (a.k.a. features) and desired outputs (a.k.a. labels), the human is effectively supervising the learning. 
If we think of the inputs as predictors, and outcomes as predicted, it is no wonder that supervised learning is very similar to statistical prediction.
When asked "are these the same?" I like to give the example of internet fraud.
If you take a sample of fraud "attacks", a statistical formulation of the problem is highly unlikely. 
This is because fraud events are not randomly drawn from some distribution, but rather, arrive from an adversary learning the defenses and adapting to it. 
This instance of supervised learning belongs in game theory, more than it does in statistics. 

Other types of machine learning problems include: TODO

- __Unsupervised learning__: See Chapter \@ref(unsupervised)
- __Semi supervised learning__: Where only part of the samples are labeled.  
- __Active learning__: Where the machine is allowed to query the user for labels. 
- __Reinforcement learning__:  
- __Structure learning__: 
- __Structural learning__: 
- __Transductive learning__:
- __Developpmental learning__:
- __Learning to learn__:
- __Manifold learning__: An instance of unsupervised learning, where the goal is to reduce the dimension of the data by embedding it into a lower dimensional manifold. A.k.a. _support estimation_.
- __Metric learning__:
- __Learning on a budget__:




## Problem setup

We now present the _empirical risk minimization_ to supervised learning. 

```{remark}
We do not discuss purely algorithmic approaches such as K-nearest neighbour and _kernel smoothing_ due to space constraints. 
For a broader review of supervised learning, see the Bibliographic Notes section.
```


Given $n$ samples with inputs $x$ from some space $\mathcal{X}$ and desired outcome, $y$, from some space $\mathcal{Y}$.
Samples, $(x,y)$ have some distribution we denote $P$.
We want to learn a function that maps inputs to outputs. 
This function is called a _hypothesis_, or _predictor_, or _classifier_ denoted $f$, that belongs to a hypothesis class $\mathcal{F}$ such that $f:\mathcal{X} \to \mathcal{Y}$.
We also choose some other function that fines us for erroneous prediction.
This function is called the _loss_, and we denote it by $l:\mathcal{Y}\times \mathcal{Y} \to \mathcal{R}^+$.

```{remark}
The _hypothesis_ in machine learning is only vaguely related the hypothese in statistical testing, which is quite confusing.
```

```{remark}
The _hypothesis_ in machine learning is not a bona-fide statistical model in that we don't assume it is the data generating process, but rather some function which we choose for its good predictive performance. 
```


The fundamental task in supervised (statistical) learning is to recover a hypothesis that minimizes the average loss. 
This is know as the _risk minimization problem_.
\begin{align}
  f^* := argmin_f \{ E_P[l(f(x),y)] \}
  (\#eq:risk)  
\end{align}

To make things more explicit, $f$ may be a linear function, and $l$ a squared error loss, in which case problem \@ref(eq:risk) collapses to 
\begin{align}
  f^* := argmin_\beta \{ E_P[(x'\beta-y)^2] \}
\end{align}

Another fundamental problem is that we do not know the distribution of all possible inputs and outputs, $P$.
We typically only have a sample of $(x_i,y_i), i=1,\dots,n$.
We thus state the _empirical_ counterpart of \@ref(eq:risk), which consists of minimizing the average loss.
This is known as the _empirical risk miminization_ problem.
\begin{align}
  \hat f := argmin_f \{ \sum_i l(f(x_i),y_i) \}
  (\#eq:erm)  
\end{align}

Making things more explicit again by using a linear hypothesis with squared loss, we see that the empirical risk minimization problem collapses to an ordinary least squares problem:
\begin{align}
  \hat f := argmin_\beta \{ \sum_i (x_\beta-y_i)^2 \}
\end{align}

If we don't assume any structure on the hypothesis, $f$, then $\hat f$ from \@ref(erm) will interpolate the data, and will be a very bad predictor. 
We say, it will _overfit_ the observed data, and will have bad performance on new data.

We have several means avoid overfitting:

1. Restrict the hypothesis class $\mathcal{F}$ (such as linear functions).
1. Penalize for the complexity of $f$. The penalty denoted by $\Vert f \Vert$.
1. Assess the loss on an independent sample. 

### Common Hypothesis Classes
Some common hypothesis classes, $\mathcal{F}$, with restricted complexity, are:

1. __Linear hypotheses__: such as linear models, GLMs, and (linear) support vector machines (SVM).
1. __Neural networks__: a.k.a. _feed-forward_ neural nets, _artificial_ neural nets, and the celebrated class of _deep_ neural nets.
1. __Reproducing Kernel Hilbert Space__: a.k.a. RKHS, is a subset of "the space of all functions^[It is even a subset of the Hilbert space, itself a subset of the space of all functions.]" that is both large enough to capture very complicated relations, but small enough so that it is less prone to overfitting, and also suprisingly simple to compute with. 
1. __Tree__: a.k.a. _decision rules_, is a class of hypotheses which can be stated as "if-then" rules. 
1. __Ensembles__: a "meta" hypothesis class, which consists of taking multiple hypotheses, possibly from different classes, and combining them. 


### Common Complexity Penalties
The most common complexity penalty applied to classes that have a finite dimensional pararametric representation, such as a the linear class parametrized via its coefficients $\beta$.
In such classes we may penalize for the norm of the parametes.
Common penalties include:

1. __Ridge penalty__: penalizing the $l_2$ norm of the parameter. I.e. $\Vert f \Vert=\Vert \beta \Vert_2^2=\sum_j \beta_j^2$. 
1. __Lasso penalty__: penalizing the $l_1$ norm of the parameter. I.e., $\Vert f \Vert=\Vert \beta \Vert_1=\sum_j |\beta_j|$
1. __Elastic net__: a combination of the lasso and ridge penalty. I.e. ,$\Vert f \Vert= \alpha \Vert \beta \Vert_2^2 + (a-\alpha) \Vert \beta \Vert_1$.

If the hypothesis class $\mathcal{F}$ does not admit a finite dimensional parametric representation, we may penalize it with some functional norm such as $\Vert f \Vert_2^2=\int f(t)^2 dt$. 


### Assessing the Loss on an Independent Sample
One way to deal with overfitting, is to assess the expected loss of a hypothesis on a new sample.

1. __Train,Validate,Test___: The simplest form of validation is to split the data. 
A _train_ set to train a set of hypotheses. 
A _validation_ set to compute the out-of-sample expected loss, and pick the best performing hypothesis. 
A _test_ sample to compute the out-of-sample performance of the selected hypothesis.
This is a very simple approach, but it is very "data inneficient", thus motivating the next method.

1. __V-fold cross validation__: 
By far the most popular performance assessment algorithm, in _V-fold CV_ we "fold" the data into $V$ non-overlapping sets. 
For each of the $V$ sets, we fit a hypothesis to the non-selected fold, and assess the expected loss on the selected loss. 
We then aggregate results over the $V$ folds, typically by averaging. 

There are many other resampling based algorithms for performance assessment. 
For an excellent review see @arlot2010survey.



### Collecting the Pieces

Collecting ideas from the above sections, a typical supervised learning pipeline will include: choosing the hypothesis class, choosing the penalty function, choosing the assessment algorithm. 

Examples of such combos include:

1. Linear regression, no penalty, train-validate test. 
1. Linear regression, $l_2$ penalty, V-fold CV. This combo is typically known as _ridge regression_.
1. Linear regression, $l_1$ penalty, V-fold CV. This combo is typically known as _lasso regression_.
1. Linear regression, $l_1$ and $l_2$ penalty, V-fold CV. This combo is typically known as _elastic net regression_.
1. Logistic regression, $l_2$ penalty, V-fold CV.
1. SVM classification, $l_2$ penalty, V-fold CV.
1. Deep network, no penalty, V-fold CV.




## Supervised Learning in R
At this point, we have a rich enough language to do supervised learning with R.

In these examples, I will use two data sets from the __ElemStatLearn__ package: 
`spam` for categorical predictions (spam mail or not spam?), and `prostate` for continuous predictions (size of cancerous tumor).
In `spam` we will try to decide if a mail is spam or not. 
In `prostate` we will try to predict the size of a cancerous tumor.

Some pre-processing. The pacakge __dplyr__ will be exaplained in the Hadley-verse Chapter \@ref(hadley).
```{r}
library(ElemStatLearn) # for data
data("prostate")
data("spam")

library(magrittr) # for piping
library(dplyr) # for handeling data frames

# Continous outcome:
prostate.train <- prostate %>% 
  filter(train) %>% 
  select(-train)
prostate.test <- prostate %>% 
  filter(!train) %>% 
  select(-train)
y.train <- prostate.train$lcavol
X.train <- prostate.train %>% select(-lcavol) %>% as.matrix
y.test <- prostate.test$lcavol 
X.test <- prostate.test %>% select(-lcavol) %>% as.matrix



# Categorical outcome:
n <- nrow(spam)

train.prop <- 0.66
train.ind <- c(TRUE,FALSE) %>%  
  sample(size = n, prob = c(train.prop,1-train.prop), replace=TRUE)
spam.train <- spam[train.ind,]
spam.test <- spam[!train.ind,]

y.train.spam <- spam.train$spam
X.train.spam <- spam.train %>% select(-spam) %>% as.matrix
y.test.spam <- spam.test$spam
X.test.spam <- spam.test %>% select(-spam) %>% as.matrix

spam.dummy <- spam %>% mutate(spam=as.numeric(spam=='spam'))
spam.train.dummy <- spam.dummy[train.ind,]
spam.test.dummy <- spam.dummy[!train.ind,]

```



```{r}
source('make_samples.R')
```
You can now call `?prostate` and `?spam` to learn more about these data sets.

We also load some utility packages and functions that we will require down the road. 
```{r preamble}
library(magrittr) # for piping
library(dplyr) # for handeling data frames

# My own utility functions:
l2 <- function(x) x^2 %>% sum %>% sqrt 
l1 <- function(x) abs(x) %>% sum  
MSE <- function(x) x^2 %>% mean 
missclassification <- function(tab) sum(tab[c(2,3)])/sum(tab)
```







## Bibliographic Notes
The ultimate reference on (statistical) machine learning is @friedman2001elements.
For a softer introduction, see @james2013introduction.
A statistician will also like @ripley2007pattern.
For an R oriented view see @lantz2013machine.
For a very algorithmic view, see the seminal @leskovec2014mining or @conway2012machine.
For a much more theoretical reference, see @mohri2012foundations, @vapnik2013nature, @shalev2014understanding.

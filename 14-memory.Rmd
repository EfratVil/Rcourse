# Memory Efficiency {#memory}

<!-- our of ram -->
<!-- databases -->

As put by @kane2013scalable, it was quite  puzzling when very few of the competitors, for the Million dollars prize in the [Netflix challenge](https://en.wikipedia.org/wiki/Netflix_Prize), were statisticians.
This is perhaps because the statistical community historically uses SAS, SPSS, and R. 
The first two tools are very well equipped to deal with big data, but are very unfriendly when when trying to implement a new method. 
R, on the other hand, is very friendly for innovation, but was not equipped to deal with the large data sets of the Netflix challenge. 
A lot has changed in R since 2006. This is the topic of this chapter. 



As we have seen in the Sparsity Chapter \@ref(sparse), an efficient representation of your data in RAM will reduce computing time, and will allow you to fit models that would otherwise require tremendous amounts of RAM.
Not all problems are sparse however. 
It is also possible that your data does not fit in RAM, even if sparse.
There are several scenarios to consider:

1. Your data fits in RAM, but is too big to compute with.
1. Your data does not fit in RAM, but fits in your local storage (HD, SSD, etc.)
1. Your data does not fit in your local storage.

If your data fits in RAM, but is too large to compute with, the solution will typically be to replace the algorithm you are using.
This will typically mean that instead of computing with the whole data, your algorithm will compute with parts of the data, also called _chunks_, or _batches_.
These algorithms are known as _external memory algorithms_ (EMA).

If your data does not fit in RAM, but fits in your local storage, you have two options.
The first is to save your data in a database.
This will allow you to use the algorithms provided by your database, or let R use an EMA while loading from your database. 
Alternatively, and preferably, you may avoid using a database, and work with the data directly form your local storage by saving your data in some efficient manner. 

Finally, if your data does not fit on you local storage, you will need some external storage solution such as a distributed database, or distributed file system.



```{remark}
If you use Linux, you may be better of than Windows users. 
Linux will allow you to compute with larger datasets using its _swap file_ that extends RAM using your HD or SSD.
On the other hand, relying on the swap file is a BAD practice since it is much slower than RAM, and you can typically do much better using the tricks of this chapter. 
Also, while I LOVE Linux, I would never dare to recommend switching to Linux just to deal with memory contraints. 
```


## Efficient Computing from RAM

If our data can fit in RAM, but is still too large to compute with it (recall that fitting a model requires roughly 5-10 times more memory than saving it), there are several facilities to be used.
The first, is the sparse representation discussed in Chapter \@ref(sparse), which is relevant when you have factors, which will typically map to sparse model matrices. 
Another way is to use memory efficient algorithms. 

The `giblm::giblm` function provides an EMA for linear regression.
The following if taken from the function's example.

```{r biglm}
data(trees)
ff<-log(Volume)~log(Girth)+log(Height)

chunk1<-trees[1:10,]
chunk2<-trees[11:20,]
chunk3<-trees[21:31,]

library(biglm)
a <- biglm(ff,chunk1)
a <- update(a,chunk2)
a <- update(a,chunk3)

coef(a)
```

Things to note:

- The data has been chunked along rows. 
- The initial fit is done with the `biglm` function.
- The model is updated with further chunks using the `update` function.

We now compare it to the in-memory version of `lm` to verify the results are the same.

```{r}
b <- lm(ff, data=trees)
rbind(coef(a),coef(b))
```

Other packages that follow these lines, particularly with classification using SVMs, are  __LiblineaR__, and __RSofia__ packages. 

We do not recommend this approach since it is limited to very particular scenarios, whereas the upcoming approaches are much more general.





## Computing from a Database

The early solutions to oversized data relied on storing your data in some relational database such as _MySQL_, _PostgresSQL_, _SQLite_, _H2_, _ODBC_, _Oracle_, etc.
Several R packages provide interfaces to these databases, such as __sqldf__, __RDBI__, __RSQite__.
Some will even include the database as part of the package itself.

Storing your data in a database has the advantage that you can typically rely on database providers to include very efficient algorithms for the queries they support. 
On the downside, SQL queries may include a lot of summary statistics, but will rarely include model fitting^[This is slowly changing. Indeed, Microsoft's SQL Server 2016 is already providing [in-database-analytics](https://blogs.technet.microsoft.com/dataplatforminsider/2016/03/29/in-database-advanced-analytics-with-r-in-sql-server-2016/), and other will surely follow.]. 
This means that even for simple things like linear models, you will have to revert to R's facilities-- typically some sort of EMA with chunking from the database. 
For this reason, and others, we prefer to compute from efficient file structures, as described in Section \@ref(file-structure).

If, however, you have a powerful database around, or you only need summary statistics, or you are an SQL master, keep reading.

The package __RSQLite__ includes an SQLite server, which we now setup for demonstration.
The packag __dplyr__, discussed in the Hadleyverse Chapter \@ref(hadley), will take care of traslating the __dplyr__ syntax, to the SQL syntax of the database. 
The following example is taken from the __dplyr__ [Databases vignette](https://cran.r-project.org/web/packages/dplyr/vignettes/databases.html).

```{r}
library(RSQLite)
library(dplyr)

file.remove('my_db.sqlite3')
my_db <- src_sqlite(path = "my_db.sqlite3", create = TRUE)

library(nycflights13)
flights_sqlite <- copy_to(
  dest= my_db, 
  df= flights, 
  temporary = FALSE, 
  indexes = list(c("year", "month", "day"), "carrier", "tailnum"))
```

Things to note:
- `src_sqlite` to starts an empty table, managed by SQLite, at the desired path.
- `copy_to` copies data from R to the database. 
- Typically, setting up a database like this makes no sense, since it requires loading the data into RAM, which is precisely what we want to avoid.

We can now start querying the database.

```{r}
select(flights_sqlite, year:day, dep_delay, arr_delay)
```

```{r}
filter(flights_sqlite, dep_delay > 240)
```

```{r}
summarise(flights_sqlite, delay = mean(dep_time))
```








## Computing From Efficient File Structrures {#file-structure}

It is possible to save your data on your storage device, without the database layer to manage it.
This has several advantages:

- You don't need to manage a database.
- You don't have the computational overhead of the database. 
- You may optimize the file structure for statistical modelling, and not for join and summary operations, as in relational databases. 

There are several facilities that allow you to save and compute directly from your storage:

1. __Memory Mapping__:
Where RAM adresses are mapped to a file on your storage. 
This extends the RAM to the capacity of your storage (HD, SSD,...).
Performance slightly deteriorates, but the access is typically very fast.
This approach is implemented in the __bigmemory__ package.

1. __Efficient binaries__:
Where the data is stored as a file on the storage device. 
The file is binary, with a well designed structure, so that chunking is easy.
This approach is implemented in the __ff__ package, and the commercial __RevoScaleR__ package. 

Your algorithms need to be aware of the facility you are using. 
For this reason each facility ( __bigmemory__, __ff__, __RevoScaleR__,...) an eco-system of packages that implement various statistical methods using that facility.
As a general rule, you can see which package builds on a package using the _Reverse Depends_ entry in the package description.
For the __bigmemory__ package, for instance, [we can see](https://cran.r-project.org/web/packages/bigmemory/index.html) that the packages __bigalgebra__, __biganalytics__, __bigFastlm__, __biglasso__, __bigpca__, __bigtabulate__, __GHap__, and __oem__, build upon it. 
We can expect this list to expand.


Here is a benchmark result, from @wang2015statistical. 
It can be seen that __ff__ and __bigmemory__ have similar performance, while __RevoScaleR__ (RRE in the figure) outperforms them.
This has to do both with the efficiency of the binary represantation, but also because __RevoScaleR__ is inherently parallel. More on this in the Parallelization Chapter \@ref(parallel).
![__bigmemory__ vs. __ff__ vs. __RevoScaleR__ when reading, trasnforming, or fitting a model to 12GB of data, on a standrard laptop (in 2015 standards).](art/benchmark.png)


We now demonstate the workflow of the __bigmemory__ package.

```{r}
# download.file("http://www.cms.gov/Research-Statistics-Data-and-Systems/Statistics-Trends-and-Reports/BSAPUFS/Downloads/2010_Carrier_PUF.zip", "2010_Carrier_PUF.zip")
# unzip(zipfile="2010_Carrier_PUF.zip")

library("bigmemory")
x <- read.big.matrix("2010_BSA_Carrier_PUF.csv", header = TRUE, 
                     backingfile = "airline.bin", 
                     descriptorfile = "airline.desc", 
                     type = "integer")
dim(x)
pryr::object_size(x)
class(x)
```

Things to note:

- The basic building block of the __bigmemory__ ecosystem, is the `big.matrix` class, we constructed with `read.big.matrix`. 
- `read.big.matrix` handles the import to R, and the saving to a memory mapped file. The implementation is such that at no point does R hold the data in RAM.
- The memory mapped file, `airline.desc` will be there after the session is over. It can thus be called by other R sessions using ` attach.big.matrix("airline.desc")`. This will be useful when parallelizing. 
-`pryr::object_size` return the size of the object. Since `x` holds only the memory mappings, it is much smaller than the 100MB of data that it holds. 

We can now start computing with the data.
Many statistical procedures for the `big.matrix` object are provided by the __biganalytics__ package. 
In particular, the `biglm.big.matrix` and `bigglm.big.matrix` functions, provide an interface from `big.matrix` objects, to the EMA linear models in `biglm::biglm` and `biglm::bigglm`.

```{r, cache=TRUE}
library(biganalytics)
biglm.2 <- bigglm.big.matrix(BENE_SEX_IDENT_CD~CAR_LINE_HCPCS_CD, data=x)
coef(biglm.2)
```

Other notable packages that operate with `big.matrix` objects include:

- __bigtabulate__: Extend the bigmemory package with 'table', 'tapply', and 'split' support for 'big.matrix' objects
- __bigalgebra__: For matrix operation.
- __bigpca__: principle components analysis (PCA), or singular value decomposition (SVD).
- __bigFastlm__: for (fast) linear models.
- __biglasso__: extends lasso and elastic nets.
- __GHap__: Haplotype calling from phased SNP data.


### Computing from a distributed file system

If your data is SOOO big that it cannot fit on your local storage, you will need a distributed file system or database.
We do not cover this topic here, and refer the reader to the __RHipe__, __RHadoop__, and __RSpark__ packages and references therein.



## Bibliographic Notes

An absolute SUPERB review on computing with big data is @wang2015statistical, and references therein (@kane2013scalable in particular). 
For an up-to-date list of the packages that deal with memory constraints, see the __Large memory and out-of-memory data__ section in the High Performance Computing [R task view](https://cran.r-project.org/web/views/HighPerformanceComputing.html).
